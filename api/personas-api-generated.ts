/* tslint:disable */
/* eslint-disable */
/*
Hyperplane API Gateway

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

The version of the OpenAPI document: 1.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ApiErrResponse } from '../models';
// @ts-ignore
import { ModelsBatchUserPersonasRequest } from '../models';
// @ts-ignore
import { ModelsCategoricalAttributeFilter } from '../models';
// @ts-ignore
import { ModelsFacetWeightObject } from '../models';
// @ts-ignore
import { ModelsListPersonasResponse } from '../models';
// @ts-ignore
import { ModelsNumericalAttributeFilter } from '../models';
// @ts-ignore
import { ModelsPercentileScore } from '../models';
// @ts-ignore
import { ModelsPersonaCreateRequest } from '../models';
// @ts-ignore
import { ModelsPersonaCreateResponse } from '../models';
// @ts-ignore
import { ModelsPersonaDetailsResponse } from '../models';
// @ts-ignore
import { ModelsPersonaUsersResponse } from '../models';
// @ts-ignore
import { ModelsPostPersonaUsersRequest } from '../models';
// @ts-ignore
import { ModelsTimestampAttributeFilter } from '../models';
// @ts-ignore
import { ModelsUserPersonasResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * PersonasApi - axios parameter creator
 * @export
 */
export const PersonasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a persona definition from a list of facet weights.  Personas enable you to define a weighted combination of interests, demographics, and financial behaviors to create highly targeted audiences for specialized use cases. They are defined using a list of facet weights, each containing a facet name and a weight. To create a persona, you must provide at least one facet weight. Each facet weight must contain a valid facet name and must be registered in the field with corresponding facet type. For example, if you want to create a persona with a facet weight for the \"Travel\" interest facet, you must provide a facet weight with the name \"Travel\" with the facet type \"interest\", the facet weight must be defined in the `interest_facets` field.
         * @summary Create a persona definition.
         * @param {ModelsPersonaCreateRequest} modelsPersonaCreateRequest Persona Request Body
         * @param {string} [modelVersion] Model Version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefinition: async (modelsPersonaCreateRequest: ModelsPersonaCreateRequest, modelVersion?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelsPersonaCreateRequest' is not null or undefined
            assertParamExists('createDefinition', 'modelsPersonaCreateRequest', modelsPersonaCreateRequest)
            const localVarPath = `/persona`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PASETO required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "pASETO", configuration })
            if (modelVersion !== undefined) {
                localVarQueryParameter['model_version'] = modelVersion;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: modelsPersonaCreateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/persona',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(modelsPersonaCreateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a custom persona for a provided `persona_id`.  Personas with facet type other than `custom` cannot be deleted. Attempting to delete a persona with facet type other than `custom` will result in a 403 Forbidden error.
         * @summary Delete a persona definition.
         * @param {string} personaId Persona ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDefinition: async (personaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('deleteDefinition', 'personaId', personaId)
            const localVarPath = `/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId !== undefined ? personaId : `-persona_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PASETO required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "pASETO", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/persona/{persona_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all personas associated with a user.
         * @summary Get all the facet attributes for a list of users.
         * @param {ModelsBatchUserPersonasRequest} modelsBatchUserPersonasRequest List of user IDs
         * @param {string} [moduleId] Module ID
         * @param {string} [month] Reference month for persona scores in &#x60;YYYY-MM&#x60; format.
         * @param {number} [personaScoreThreshold] Minimum user persona score threshold to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFacetAttributes: async (modelsBatchUserPersonasRequest: ModelsBatchUserPersonasRequest, moduleId?: string, month?: string, personaScoreThreshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelsBatchUserPersonasRequest' is not null or undefined
            assertParamExists('getAllFacetAttributes', 'modelsBatchUserPersonasRequest', modelsBatchUserPersonasRequest)
            const localVarPath = `/batch/user/personas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PASETO required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "pASETO", configuration })
            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (personaScoreThreshold !== undefined) {
                localVarQueryParameter['persona_score_threshold'] = personaScoreThreshold;
            }

            if (moduleId != null) {
                localVarHeaderParameter['module-id'] = String(moduleId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: modelsBatchUserPersonasRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/batch/user/personas',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(modelsBatchUserPersonasRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the score associated with a given percentile for a persona id.
         * @summary Fetch score on a given percentile for a persona id.
         * @param {string} personaId Persona ID
         * @param {number} percentile Target percentile. Defaults to 50th percentile (i.e.: the median)
         * @param {string} [moduleId] Module ID
         * @param {string} [month] Reference month for persona scores in &#x60;YYYY-MM&#x60; format. Defaults to current month.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPercentileScore: async (personaId: string, percentile: number, moduleId?: string, month?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('getPercentileScore', 'personaId', personaId)
            // verify required parameter 'percentile' is not null or undefined
            assertParamExists('getPercentileScore', 'percentile', percentile)
            const localVarPath = `/persona/{persona_id}/percentile_score`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId !== undefined ? personaId : `-persona_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PASETO required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "pASETO", configuration })
            if (percentile !== undefined) {
                localVarQueryParameter['percentile'] = percentile;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (moduleId != null) {
                localVarHeaderParameter['module-id'] = String(moduleId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/persona/{persona_id}/percentile_score',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns statistics and information about a persona definition.  The response includes the original persona definition, its creation date, as well as statistics about the persona\'s score distribution (e.g. number of users, average score, score percentiles, etc.). You can also specify the minimum persona score threshold that a user must meet to be included in the response.  You must provide a valid persona ID. Otherwise, a 404 (Not Found) error will be returned.
         * @summary Fetch information and score statistics about a persona definition.
         * @param {string} personaId Persona ID
         * @param {string} [moduleId] Module ID
         * @param {string} [month] Reference month for persona scores in &#x60;YYYY-MM&#x60; format. Defaults to current month.
         * @param {number} [personaScoreThreshold] Minimum user persona score threshold to count a user as belonging to a persona in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaStatistics: async (personaId: string, moduleId?: string, month?: string, personaScoreThreshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('getPersonaStatistics', 'personaId', personaId)
            const localVarPath = `/persona/{persona_id}`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId !== undefined ? personaId : `-persona_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PASETO required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "pASETO", configuration })
            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (personaScoreThreshold !== undefined) {
                localVarQueryParameter['persona_score_threshold'] = personaScoreThreshold;
            }

            if (moduleId != null) {
                localVarHeaderParameter['module-id'] = String(moduleId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/persona/{persona_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a ranked list of users who match a persona definition.  Users are sorted by their persona score, with the highest scoring users appearing first. Results are paginated by default, with 500 users per page. You can specify the page number and page size by passing the `page_number` and `page_size` query parameters. (e.g. `GET /persona/{persona_id}/users?page_number=2&page_size=100`)  You can also specify the minimum persona score threshold that a user must meet to be included in the response. If not specified, will default to the hyperplane suggested threshold for the given persona_id.  You can also use a blocklist to exclude specific users from the response.
         * @summary Get ranked list of users who match a persona definition.
         * @param {string} personaId Persona ID
         * @param {ModelsPostPersonaUsersRequest} modelsPostPersonaUsersRequest Optional user filters
         * @param {string} [moduleId] Module ID
         * @param {number} [pageNumber] Page number, starting at 1
         * @param {number} [pageSize] Number of users scored in run per page, between 1 and 10000. Defaults to 500.
         * @param {string} [month] Reference month for persona scores in &#x60;YYYY-MM&#x60; format. Defaults to current month.
         * @param {number} [personaScoreThreshold] Minimum user persona score threshold for user to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankedUsers: async (personaId: string, modelsPostPersonaUsersRequest: ModelsPostPersonaUsersRequest, moduleId?: string, pageNumber?: number, pageSize?: number, month?: string, personaScoreThreshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'personaId' is not null or undefined
            assertParamExists('getRankedUsers', 'personaId', personaId)
            // verify required parameter 'modelsPostPersonaUsersRequest' is not null or undefined
            assertParamExists('getRankedUsers', 'modelsPostPersonaUsersRequest', modelsPostPersonaUsersRequest)
            const localVarPath = `/persona/{persona_id}/users`
                .replace(`{${"persona_id"}}`, encodeURIComponent(String(personaId !== undefined ? personaId : `-persona_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PASETO required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "pASETO", configuration })
            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (personaScoreThreshold !== undefined) {
                localVarQueryParameter['persona_score_threshold'] = personaScoreThreshold;
            }

            if (moduleId != null) {
                localVarHeaderParameter['module-id'] = String(moduleId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: modelsPostPersonaUsersRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/persona/{persona_id}/users',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(modelsPostPersonaUsersRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all existing personas.  Personas are sorted by creation date, with the most recently created personas appearing first. By default, all personas are returned. However, you can specify the type of personas you want by passing specific facet types as a query parameter. (e.g. `GET /persona?facet_types=interest,demographic`) Optionally, you can paginate the results by specifying the `page_number` and `page_size` query parameters. If either `page_number` and `page_size` are not specified, all personas will be returned.
         * @summary List existing personas.
         * @param {string} [facetTypes] Comma-separated facet types to select. By default, all personas are returned. Valid facet types are: interest, demographic, pre_defined_persona, custom.
         * @param {string} [moduleId] Module ID
         * @param {number} [pageNumber] Page number, starting at 1
         * @param {number} [pageSize] Number of personas per page, between 1 and 10000. Will return all personas if not specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExisting: async (facetTypes?: string, moduleId?: string, pageNumber?: number, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/persona`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PASETO required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "pASETO", configuration })
            if (facetTypes !== undefined) {
                localVarQueryParameter['facet_types'] = facetTypes;
            }

            if (pageNumber !== undefined) {
                localVarQueryParameter['page_number'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (moduleId != null) {
                localVarHeaderParameter['module-id'] = String(moduleId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/persona',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of personas and their scores for a given user. Personas are sorted by their persona score, in descending order.  You can also specify the minimum persona score threshold that a user must meet to be included in the response. Defaults to hyperplane\'s suggested threshold to determine if the user belongs to the persona.
         * @summary List personas associated with a user.
         * @param {string} userId User ID
         * @param {string} [moduleId] Module ID
         * @param {string} [month] Reference month for persona scores in &#x60;YYYY-MM&#x60; format.
         * @param {number} [personaScoreThreshold] Minimum user persona score threshold to be included in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPersonas: async (userId: string, moduleId?: string, month?: string, personaScoreThreshold?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listUserPersonas', 'userId', userId)
            const localVarPath = `/users/{user_id}/personas`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication PASETO required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "pASETO", configuration })
            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            if (personaScoreThreshold !== undefined) {
                localVarQueryParameter['persona_score_threshold'] = personaScoreThreshold;
            }

            if (moduleId != null) {
                localVarHeaderParameter['module-id'] = String(moduleId);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}/personas',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PersonasApi - functional programming interface
 * @export
 */
export const PersonasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PersonasApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a persona definition from a list of facet weights.  Personas enable you to define a weighted combination of interests, demographics, and financial behaviors to create highly targeted audiences for specialized use cases. They are defined using a list of facet weights, each containing a facet name and a weight. To create a persona, you must provide at least one facet weight. Each facet weight must contain a valid facet name and must be registered in the field with corresponding facet type. For example, if you want to create a persona with a facet weight for the \"Travel\" interest facet, you must provide a facet weight with the name \"Travel\" with the facet type \"interest\", the facet weight must be defined in the `interest_facets` field.
         * @summary Create a persona definition.
         * @param {PersonasApiCreateDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDefinition(requestParameters: PersonasApiCreateDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsPersonaCreateResponse>> {
            const modelsPersonaCreateRequest: ModelsPersonaCreateRequest = {
                company_facets: requestParameters.company_facets,
                demographic_facets: requestParameters.demographic_facets,
                interest_facets: requestParameters.interest_facets,
                locations: requestParameters.locations,
                persona_name: requestParameters.persona_name,
                pre_defined_personas: requestParameters.pre_defined_personas
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDefinition(modelsPersonaCreateRequest, requestParameters.modelVersion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a custom persona for a provided `persona_id`.  Personas with facet type other than `custom` cannot be deleted. Attempting to delete a persona with facet type other than `custom` will result in a 403 Forbidden error.
         * @summary Delete a persona definition.
         * @param {PersonasApiDeleteDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDefinition(requestParameters: PersonasApiDeleteDefinitionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDefinition(requestParameters.personaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all personas associated with a user.
         * @summary Get all the facet attributes for a list of users.
         * @param {PersonasApiGetAllFacetAttributesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFacetAttributes(requestParameters: PersonasApiGetAllFacetAttributesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModelsUserPersonasResponse>>> {
            const modelsBatchUserPersonasRequest: ModelsBatchUserPersonasRequest = {
                user_ids: requestParameters.user_ids
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFacetAttributes(modelsBatchUserPersonasRequest, requestParameters.moduleId, requestParameters.month, requestParameters.personaScoreThreshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the score associated with a given percentile for a persona id.
         * @summary Fetch score on a given percentile for a persona id.
         * @param {PersonasApiGetPercentileScoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPercentileScore(requestParameters: PersonasApiGetPercentileScoreRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsPercentileScore>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPercentileScore(requestParameters.personaId, requestParameters.percentile, requestParameters.moduleId, requestParameters.month, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns statistics and information about a persona definition.  The response includes the original persona definition, its creation date, as well as statistics about the persona\'s score distribution (e.g. number of users, average score, score percentiles, etc.). You can also specify the minimum persona score threshold that a user must meet to be included in the response.  You must provide a valid persona ID. Otherwise, a 404 (Not Found) error will be returned.
         * @summary Fetch information and score statistics about a persona definition.
         * @param {PersonasApiGetPersonaStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPersonaStatistics(requestParameters: PersonasApiGetPersonaStatisticsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsPersonaDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPersonaStatistics(requestParameters.personaId, requestParameters.moduleId, requestParameters.month, requestParameters.personaScoreThreshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a ranked list of users who match a persona definition.  Users are sorted by their persona score, with the highest scoring users appearing first. Results are paginated by default, with 500 users per page. You can specify the page number and page size by passing the `page_number` and `page_size` query parameters. (e.g. `GET /persona/{persona_id}/users?page_number=2&page_size=100`)  You can also specify the minimum persona score threshold that a user must meet to be included in the response. If not specified, will default to the hyperplane suggested threshold for the given persona_id.  You can also use a blocklist to exclude specific users from the response.
         * @summary Get ranked list of users who match a persona definition.
         * @param {PersonasApiGetRankedUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankedUsers(requestParameters: PersonasApiGetRankedUsersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsPersonaUsersResponse>> {
            const modelsPostPersonaUsersRequest: ModelsPostPersonaUsersRequest = {
                birth_date: requestParameters.birth_date,
                blocklist: requestParameters.blocklist,
                branch: requestParameters.branch,
                cbo_code: requestParameters.cbo_code,
                declared_monthly_income: requestParameters.declared_monthly_income,
                job_title: requestParameters.job_title
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRankedUsers(requestParameters.personaId, modelsPostPersonaUsersRequest, requestParameters.moduleId, requestParameters.pageNumber, requestParameters.pageSize, requestParameters.month, requestParameters.personaScoreThreshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists all existing personas.  Personas are sorted by creation date, with the most recently created personas appearing first. By default, all personas are returned. However, you can specify the type of personas you want by passing specific facet types as a query parameter. (e.g. `GET /persona?facet_types=interest,demographic`) Optionally, you can paginate the results by specifying the `page_number` and `page_size` query parameters. If either `page_number` and `page_size` are not specified, all personas will be returned.
         * @summary List existing personas.
         * @param {PersonasApiListExistingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExisting(requestParameters: PersonasApiListExistingRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsListPersonasResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExisting(requestParameters.facetTypes, requestParameters.moduleId, requestParameters.pageNumber, requestParameters.pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of personas and their scores for a given user. Personas are sorted by their persona score, in descending order.  You can also specify the minimum persona score threshold that a user must meet to be included in the response. Defaults to hyperplane\'s suggested threshold to determine if the user belongs to the persona.
         * @summary List personas associated with a user.
         * @param {PersonasApiListUserPersonasRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserPersonas(requestParameters: PersonasApiListUserPersonasRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelsUserPersonasResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserPersonas(requestParameters.userId, requestParameters.moduleId, requestParameters.month, requestParameters.personaScoreThreshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PersonasApi - factory interface
 * @export
 */
export const PersonasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PersonasApiFp(configuration)
    return {
        /**
         * Creates a persona definition from a list of facet weights.  Personas enable you to define a weighted combination of interests, demographics, and financial behaviors to create highly targeted audiences for specialized use cases. They are defined using a list of facet weights, each containing a facet name and a weight. To create a persona, you must provide at least one facet weight. Each facet weight must contain a valid facet name and must be registered in the field with corresponding facet type. For example, if you want to create a persona with a facet weight for the \"Travel\" interest facet, you must provide a facet weight with the name \"Travel\" with the facet type \"interest\", the facet weight must be defined in the `interest_facets` field.
         * @summary Create a persona definition.
         * @param {PersonasApiCreateDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDefinition(requestParameters: PersonasApiCreateDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<ModelsPersonaCreateResponse> {
            return localVarFp.createDefinition(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a custom persona for a provided `persona_id`.  Personas with facet type other than `custom` cannot be deleted. Attempting to delete a persona with facet type other than `custom` will result in a 403 Forbidden error.
         * @summary Delete a persona definition.
         * @param {PersonasApiDeleteDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDefinition(requestParameters: PersonasApiDeleteDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteDefinition(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all personas associated with a user.
         * @summary Get all the facet attributes for a list of users.
         * @param {PersonasApiGetAllFacetAttributesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFacetAttributes(requestParameters: PersonasApiGetAllFacetAttributesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ModelsUserPersonasResponse>> {
            return localVarFp.getAllFacetAttributes(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the score associated with a given percentile for a persona id.
         * @summary Fetch score on a given percentile for a persona id.
         * @param {PersonasApiGetPercentileScoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPercentileScore(requestParameters: PersonasApiGetPercentileScoreRequest, options?: AxiosRequestConfig): AxiosPromise<ModelsPercentileScore> {
            return localVarFp.getPercentileScore(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns statistics and information about a persona definition.  The response includes the original persona definition, its creation date, as well as statistics about the persona\'s score distribution (e.g. number of users, average score, score percentiles, etc.). You can also specify the minimum persona score threshold that a user must meet to be included in the response.  You must provide a valid persona ID. Otherwise, a 404 (Not Found) error will be returned.
         * @summary Fetch information and score statistics about a persona definition.
         * @param {PersonasApiGetPersonaStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPersonaStatistics(requestParameters: PersonasApiGetPersonaStatisticsRequest, options?: AxiosRequestConfig): AxiosPromise<ModelsPersonaDetailsResponse> {
            return localVarFp.getPersonaStatistics(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a ranked list of users who match a persona definition.  Users are sorted by their persona score, with the highest scoring users appearing first. Results are paginated by default, with 500 users per page. You can specify the page number and page size by passing the `page_number` and `page_size` query parameters. (e.g. `GET /persona/{persona_id}/users?page_number=2&page_size=100`)  You can also specify the minimum persona score threshold that a user must meet to be included in the response. If not specified, will default to the hyperplane suggested threshold for the given persona_id.  You can also use a blocklist to exclude specific users from the response.
         * @summary Get ranked list of users who match a persona definition.
         * @param {PersonasApiGetRankedUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankedUsers(requestParameters: PersonasApiGetRankedUsersRequest, options?: AxiosRequestConfig): AxiosPromise<ModelsPersonaUsersResponse> {
            return localVarFp.getRankedUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all existing personas.  Personas are sorted by creation date, with the most recently created personas appearing first. By default, all personas are returned. However, you can specify the type of personas you want by passing specific facet types as a query parameter. (e.g. `GET /persona?facet_types=interest,demographic`) Optionally, you can paginate the results by specifying the `page_number` and `page_size` query parameters. If either `page_number` and `page_size` are not specified, all personas will be returned.
         * @summary List existing personas.
         * @param {PersonasApiListExistingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExisting(requestParameters: PersonasApiListExistingRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ModelsListPersonasResponse> {
            return localVarFp.listExisting(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of personas and their scores for a given user. Personas are sorted by their persona score, in descending order.  You can also specify the minimum persona score threshold that a user must meet to be included in the response. Defaults to hyperplane\'s suggested threshold to determine if the user belongs to the persona.
         * @summary List personas associated with a user.
         * @param {PersonasApiListUserPersonasRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPersonas(requestParameters: PersonasApiListUserPersonasRequest, options?: AxiosRequestConfig): AxiosPromise<ModelsUserPersonasResponse> {
            return localVarFp.listUserPersonas(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createDefinition operation in PersonasApi.
 * @export
 * @interface PersonasApiCreateDefinitionRequest
 */
export type PersonasApiCreateDefinitionRequest = {
    
    /**
    * Model Version
    * @type {string}
    * @memberof PersonasApiCreateDefinition
    */
    readonly modelVersion?: string
    
} & ModelsPersonaCreateRequest

/**
 * Request parameters for deleteDefinition operation in PersonasApi.
 * @export
 * @interface PersonasApiDeleteDefinitionRequest
 */
export type PersonasApiDeleteDefinitionRequest = {
    
    /**
    * Persona ID
    * @type {string}
    * @memberof PersonasApiDeleteDefinition
    */
    readonly personaId: string
    
}

/**
 * Request parameters for getAllFacetAttributes operation in PersonasApi.
 * @export
 * @interface PersonasApiGetAllFacetAttributesRequest
 */
export type PersonasApiGetAllFacetAttributesRequest = {
    
    /**
    * Module ID
    * @type {string}
    * @memberof PersonasApiGetAllFacetAttributes
    */
    readonly moduleId?: string
    
    /**
    * Reference month for persona scores in `YYYY-MM` format.
    * @type {string}
    * @memberof PersonasApiGetAllFacetAttributes
    */
    readonly month?: string
    
    /**
    * Minimum user persona score threshold to be included in the response.
    * @type {number}
    * @memberof PersonasApiGetAllFacetAttributes
    */
    readonly personaScoreThreshold?: number
    
} & ModelsBatchUserPersonasRequest

/**
 * Request parameters for getPercentileScore operation in PersonasApi.
 * @export
 * @interface PersonasApiGetPercentileScoreRequest
 */
export type PersonasApiGetPercentileScoreRequest = {
    
    /**
    * Persona ID
    * @type {string}
    * @memberof PersonasApiGetPercentileScore
    */
    readonly personaId: string
    
    /**
    * Target percentile. Defaults to 50th percentile (i.e.: the median)
    * @type {number}
    * @memberof PersonasApiGetPercentileScore
    */
    readonly percentile: number
    
    /**
    * Module ID
    * @type {string}
    * @memberof PersonasApiGetPercentileScore
    */
    readonly moduleId?: string
    
    /**
    * Reference month for persona scores in `YYYY-MM` format. Defaults to current month.
    * @type {string}
    * @memberof PersonasApiGetPercentileScore
    */
    readonly month?: string
    
}

/**
 * Request parameters for getPersonaStatistics operation in PersonasApi.
 * @export
 * @interface PersonasApiGetPersonaStatisticsRequest
 */
export type PersonasApiGetPersonaStatisticsRequest = {
    
    /**
    * Persona ID
    * @type {string}
    * @memberof PersonasApiGetPersonaStatistics
    */
    readonly personaId: string
    
    /**
    * Module ID
    * @type {string}
    * @memberof PersonasApiGetPersonaStatistics
    */
    readonly moduleId?: string
    
    /**
    * Reference month for persona scores in `YYYY-MM` format. Defaults to current month.
    * @type {string}
    * @memberof PersonasApiGetPersonaStatistics
    */
    readonly month?: string
    
    /**
    * Minimum user persona score threshold to count a user as belonging to a persona in the response.
    * @type {number}
    * @memberof PersonasApiGetPersonaStatistics
    */
    readonly personaScoreThreshold?: number
    
}

/**
 * Request parameters for getRankedUsers operation in PersonasApi.
 * @export
 * @interface PersonasApiGetRankedUsersRequest
 */
export type PersonasApiGetRankedUsersRequest = {
    
    /**
    * Persona ID
    * @type {string}
    * @memberof PersonasApiGetRankedUsers
    */
    readonly personaId: string
    
    /**
    * Module ID
    * @type {string}
    * @memberof PersonasApiGetRankedUsers
    */
    readonly moduleId?: string
    
    /**
    * Page number, starting at 1
    * @type {number}
    * @memberof PersonasApiGetRankedUsers
    */
    readonly pageNumber?: number
    
    /**
    * Number of users scored in run per page, between 1 and 10000. Defaults to 500.
    * @type {number}
    * @memberof PersonasApiGetRankedUsers
    */
    readonly pageSize?: number
    
    /**
    * Reference month for persona scores in `YYYY-MM` format. Defaults to current month.
    * @type {string}
    * @memberof PersonasApiGetRankedUsers
    */
    readonly month?: string
    
    /**
    * Minimum user persona score threshold for user to be included in the response.
    * @type {number}
    * @memberof PersonasApiGetRankedUsers
    */
    readonly personaScoreThreshold?: number
    
} & ModelsPostPersonaUsersRequest

/**
 * Request parameters for listExisting operation in PersonasApi.
 * @export
 * @interface PersonasApiListExistingRequest
 */
export type PersonasApiListExistingRequest = {
    
    /**
    * Comma-separated facet types to select. By default, all personas are returned. Valid facet types are: interest, demographic, pre_defined_persona, custom.
    * @type {string}
    * @memberof PersonasApiListExisting
    */
    readonly facetTypes?: string
    
    /**
    * Module ID
    * @type {string}
    * @memberof PersonasApiListExisting
    */
    readonly moduleId?: string
    
    /**
    * Page number, starting at 1
    * @type {number}
    * @memberof PersonasApiListExisting
    */
    readonly pageNumber?: number
    
    /**
    * Number of personas per page, between 1 and 10000. Will return all personas if not specified.
    * @type {number}
    * @memberof PersonasApiListExisting
    */
    readonly pageSize?: number
    
}

/**
 * Request parameters for listUserPersonas operation in PersonasApi.
 * @export
 * @interface PersonasApiListUserPersonasRequest
 */
export type PersonasApiListUserPersonasRequest = {
    
    /**
    * User ID
    * @type {string}
    * @memberof PersonasApiListUserPersonas
    */
    readonly userId: string
    
    /**
    * Module ID
    * @type {string}
    * @memberof PersonasApiListUserPersonas
    */
    readonly moduleId?: string
    
    /**
    * Reference month for persona scores in `YYYY-MM` format.
    * @type {string}
    * @memberof PersonasApiListUserPersonas
    */
    readonly month?: string
    
    /**
    * Minimum user persona score threshold to be included in the response.
    * @type {number}
    * @memberof PersonasApiListUserPersonas
    */
    readonly personaScoreThreshold?: number
    
}

/**
 * PersonasApiGenerated - object-oriented interface
 * @export
 * @class PersonasApiGenerated
 * @extends {BaseAPI}
 */
export class PersonasApiGenerated extends BaseAPI {
    /**
     * Creates a persona definition from a list of facet weights.  Personas enable you to define a weighted combination of interests, demographics, and financial behaviors to create highly targeted audiences for specialized use cases. They are defined using a list of facet weights, each containing a facet name and a weight. To create a persona, you must provide at least one facet weight. Each facet weight must contain a valid facet name and must be registered in the field with corresponding facet type. For example, if you want to create a persona with a facet weight for the \"Travel\" interest facet, you must provide a facet weight with the name \"Travel\" with the facet type \"interest\", the facet weight must be defined in the `interest_facets` field.
     * @summary Create a persona definition.
     * @param {PersonasApiCreateDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApiGenerated
     */
    public createDefinition(requestParameters: PersonasApiCreateDefinitionRequest, options?: AxiosRequestConfig) {
        return PersonasApiFp(this.configuration).createDefinition(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a custom persona for a provided `persona_id`.  Personas with facet type other than `custom` cannot be deleted. Attempting to delete a persona with facet type other than `custom` will result in a 403 Forbidden error.
     * @summary Delete a persona definition.
     * @param {PersonasApiDeleteDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApiGenerated
     */
    public deleteDefinition(requestParameters: PersonasApiDeleteDefinitionRequest, options?: AxiosRequestConfig) {
        return PersonasApiFp(this.configuration).deleteDefinition(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all personas associated with a user.
     * @summary Get all the facet attributes for a list of users.
     * @param {PersonasApiGetAllFacetAttributesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApiGenerated
     */
    public getAllFacetAttributes(requestParameters: PersonasApiGetAllFacetAttributesRequest, options?: AxiosRequestConfig) {
        return PersonasApiFp(this.configuration).getAllFacetAttributes(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the score associated with a given percentile for a persona id.
     * @summary Fetch score on a given percentile for a persona id.
     * @param {PersonasApiGetPercentileScoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApiGenerated
     */
    public getPercentileScore(requestParameters: PersonasApiGetPercentileScoreRequest, options?: AxiosRequestConfig) {
        return PersonasApiFp(this.configuration).getPercentileScore(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns statistics and information about a persona definition.  The response includes the original persona definition, its creation date, as well as statistics about the persona\'s score distribution (e.g. number of users, average score, score percentiles, etc.). You can also specify the minimum persona score threshold that a user must meet to be included in the response.  You must provide a valid persona ID. Otherwise, a 404 (Not Found) error will be returned.
     * @summary Fetch information and score statistics about a persona definition.
     * @param {PersonasApiGetPersonaStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApiGenerated
     */
    public getPersonaStatistics(requestParameters: PersonasApiGetPersonaStatisticsRequest, options?: AxiosRequestConfig) {
        return PersonasApiFp(this.configuration).getPersonaStatistics(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a ranked list of users who match a persona definition.  Users are sorted by their persona score, with the highest scoring users appearing first. Results are paginated by default, with 500 users per page. You can specify the page number and page size by passing the `page_number` and `page_size` query parameters. (e.g. `GET /persona/{persona_id}/users?page_number=2&page_size=100`)  You can also specify the minimum persona score threshold that a user must meet to be included in the response. If not specified, will default to the hyperplane suggested threshold for the given persona_id.  You can also use a blocklist to exclude specific users from the response.
     * @summary Get ranked list of users who match a persona definition.
     * @param {PersonasApiGetRankedUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApiGenerated
     */
    public getRankedUsers(requestParameters: PersonasApiGetRankedUsersRequest, options?: AxiosRequestConfig) {
        return PersonasApiFp(this.configuration).getRankedUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all existing personas.  Personas are sorted by creation date, with the most recently created personas appearing first. By default, all personas are returned. However, you can specify the type of personas you want by passing specific facet types as a query parameter. (e.g. `GET /persona?facet_types=interest,demographic`) Optionally, you can paginate the results by specifying the `page_number` and `page_size` query parameters. If either `page_number` and `page_size` are not specified, all personas will be returned.
     * @summary List existing personas.
     * @param {PersonasApiListExistingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApiGenerated
     */
    public listExisting(requestParameters: PersonasApiListExistingRequest = {}, options?: AxiosRequestConfig) {
        return PersonasApiFp(this.configuration).listExisting(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of personas and their scores for a given user. Personas are sorted by their persona score, in descending order.  You can also specify the minimum persona score threshold that a user must meet to be included in the response. Defaults to hyperplane\'s suggested threshold to determine if the user belongs to the persona.
     * @summary List personas associated with a user.
     * @param {PersonasApiListUserPersonasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PersonasApiGenerated
     */
    public listUserPersonas(requestParameters: PersonasApiListUserPersonasRequest, options?: AxiosRequestConfig) {
        return PersonasApiFp(this.configuration).listUserPersonas(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
